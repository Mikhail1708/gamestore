def count_points_in_square():
    """Определяет количество точек, попадающих в квадрат"""
    print("\nЗАДАЧА 2: Подсчет точек в квадрате")
    print("-" * 50)
    
    try:
        # Ввод данных
        n = int(input("Введите количество точек (n): "))
        a = float(input("Введите координату a центра квадрата: "))
        b = float(input("Введите координату b центра квадрата: "))
        
        # Квадрат: сторона = 2, центр (a, b)
        # Границы квадрата: [a-1, a+1] по X, [b-1, b+1] по Y
        count = 0
        points_in_square = []
        
        print(f"\nКвадрат имеет центр в точке ({a}, {b}) и сторону 2.")
        print(f"Границы квадрата: x ∈ [{a-1}, {a+1}], y ∈ [{b-1}, {b+1}]")
        print("\nВведите координаты точек:")
        print("-" * 50)
        
        # Ввод и проверка каждой точки
        for i in range(1, n + 1):
            x = float(input(f"Точка {i}, координата x: "))
            y = float(input(f"Точка {i}, координата y: "))
            
            # Проверка попадания в квадрат
            if (a - 1 <= x <= a + 1) and (b - 1 <= y <= b + 1):
                count += 1
                points_in_square.append((x, y))
                print(f"  ✓ Точка ({x}, {y}) находится ВНУТРИ квадрата")
            else:
                print(f"  ✗ Точка ({x}, {y}) находится СНАРУЖИ квадрата")
        
        # Вывод результатов
        print("\n" + "=" * 50)
        print("РЕЗУЛЬТАТЫ:")
        print("=" * 50)
        print(f"Всего точек: {n}")
        print(f"Точек в квадрате: {count}")
        
        if count > 0:
            print(f"Координаты точек внутри квадрата:")
            for point in points_in_square:
                print(f"  ({point[0]}, {point[1]})")
        else:
            print("В квадрате нет точек.")
            
    except ValueError:
        print("Ошибка! Пожалуйста, вводите числовые значения.")
    except Exception as e:
        print(f"Произошла ошибка: {e}")

# Запуск обеих задач
if __name__ == "__main__":
    # Задача 1 (автоматический расчет)
    primes, result = sum_of_squares_first_seven_primes()
    
    print("=" * 60)
    print("ЗАДАЧА 1: Сумма квадратов первых семи простых чисел")
    print("=" * 60)
    print(f"Первые 7 простых чисел: {primes}")
    print(f"Сумма их квадратов: {result}")
    print(f"Расчет: {' + '.join(f'{p}²' for p in primes)} = {' + '.join(str(p**2) for p in primes)} = {result}")
    print("=" * 60)
    
    # Задача 2 (интерактивный ввод)
    count_points_in_square()


def is_prime(num):
    """Проверяет, является ли число простым"""
    if num < 2:
        return False
    if num == 2:
        return True
    if num % 2 == 0:
        return False
    
    # Проверяем делители до квадратного корня
    for i in range(3, int(num**0.5) + 1, 2):
        if num % i == 0:
            return False
    return True

def sum_of_squares_first_seven_primes():
    """Вычисляет сумму квадратов первых семи простых чисел"""
    primes = []
    current_num = 2
    
    while len(primes) < 7:
        if is_prime(current_num):
            primes.append(current_num)
        current_num += 1
    
    # Вычисляем сумму квадратов
    sum_squares = sum(p**2 for p in primes)
    
    return primes, sum_squares

# Выполнение задачи 1
print("=" * 50)
print("ЗАДАЧА 1: Сумма квадратов первых семи простых чисел")
print("=" * 50)

primes, result = sum_of_squares_first_seven_primes()

print(f"Первые 7 простых чисел: {primes}")
print(f"Их квадраты: {[p**2 for p in primes]}")
print(f"\nСумма квадратов: {result}")
print(f"\nПодробный расчет:")
for i, prime in enumerate(primes, 1):
    print(f"{prime}² = {prime**2}")
print(f"\nИтого: {' + '.join(str(p**2) for p in primes)} = {result}")
print("=" * 50)
def next_row(row):
    """Генерирует следующую строку треугольника Паскаля."""
    row = [1] + row
    for i in range(1, len(row) - 1):
        row[i] += row[i + 1]
    return row

def print_pascal_triangle(n):
    """Красиво выводит треугольник Паскаля."""
    all_rows = []
    
    # Собираем все строки
    row = []
    for i in range(n):
        row = next_row(row)
        all_rows.append(row[:])  # сохраняем копию
    
    # Находим максимальную ширину последней строки
    max_width = len(' '.join(str(x) for x in all_rows[-1]))
    
    # Выводим строки с центрированием
    for row in all_rows:
        row_str = '   '.join(str(num) for num in row)
        print(row_str.center(max_width))

# Основная программа
if __name__ == "__main__":
    n = int(input("Введите количество строк треугольника: "))
    print("\n" + "ТРЕУГОЛЬНИК ПАСКАЛЯ".center(50))
    print("=" * 50)
    print_pascal_triangle(n)

def check_palindrome(text: str) -> str:
    cleaned = ''.join(char.lower() for char in text if char.isalnum())
    
    if cleaned == cleaned[::-1] and cleaned:
        return f"✓ '{text}' — это палиндром!"
    return f"✗ '{text}' — это НЕ палиндром"

# Интерактивный режим
print("=== ПРОВЕРКА ПАЛИНДРОМОВ ===")
print("(Для выхода введите 'exit')\n")

while True:
    user_input = input("Введите строку для проверки: ").strip()
    
    if user_input.lower() == 'exit':
        print("Программа завершена.")
        break
    
    if not user_input:
        print("⚠ Вы ввели пустую строку!\n")
        continue
    
    result = check_palindrome(user_input)
    print(result + "\n")


def is_palindrome(s: str) -> bool:
    s = ''.join(c.lower() for c in s if c.isalnum())
    for i in range(len(s) // 2):
        if s[i] != s[-(i + 1)]:
            return False
    return True


import math

def simple_iteration(phi, x0, eps=0.001, max_iter=100):
    """
    Решение уравнения x = phi(x) методом простой итерации
    """
    x_prev = x0
    print(f"Начальное приближение: x₀ = {x0}")
    print(f"Требуемая точность: ε = {eps}")
    print("-" * 60)
    print(f"{'Итерация':<10} {'xₙ':<15} {'xₙ₊₁ = φ(xₙ)':<20} {'|xₙ₊₁ - xₙ|':<15}")
    print("-" * 60)
    
    for i in range(max_iter):
        x_next = phi(x_prev)
        diff = abs(x_next - x_prev)
        
        print(f"{i:<10} {x_prev:<15.6f} {x_next:<20.6f} {diff:<15.6f}")
        
        # Проверка условия остановки
        if diff < eps:
            print("-" * 60)
            print(f"\nУсловие |xₙ₊₁ - xₙ| < ε достигнуто на итерации {i+1}")
            return x_next, i + 1
        
        x_prev = x_next
    
    print("-" * 60)
    print(f"\nДостигнуто максимальное число итераций ({max_iter})")
    return x_prev, max_iter


def main():
    print("МЕТОД ПРОСТОЙ ИТЕРАЦИИ")
    print("=" * 60)
    print("Решение уравнения: x³ - x - 1 = 0")
    print("Преобразование: x = ∛(x + 1)")
    print("=" * 60)
    
    # Итерационная функция: φ(x) = ∛(x + 1)
    phi = lambda x: (x + 1) ** (1/3)
    
    # Параметры метода
    x0 = 1.0          # Начальное приближение
    eps = 0.001       # Точность
    
    # Решение уравнения
    root, iterations = simple_iteration(phi, x0, eps)
    
    # Вывод результатов
    print(f"\nРЕЗУЛЬТАТЫ:")
    print(f"Приближенный корень: x ≈ {root:.6f}")
    print(f"Количество итераций: {iterations}")
    
    # Проверка решения
    f_root = root**3 - root - 1
    print(f"Проверка: f({root:.6f}) = {root:.6f}³ - {root:.6f} - 1 = {f_root:.6f}")
    
    # Точное значение для сравнения
    print(f"\nТочное значение корня: ≈ 1.324717957")
    print(f"Погрешность: {abs(root - 1.324717957):.10f}")
    
    # Проверка условия сходимости
    print("\n" + "=" * 60)
    print("ПРОВЕРКА УСЛОВИЯ СХОДИМОСТИ:")
    print("Метод сходится, если |φ'(x)| < 1 в окрестности корня")
    
    # Производная φ(x) = ∛(x + 1)
    # φ'(x) = 1/(3*(x+1)^(2/3))
    phi_prime = lambda x: 1 / (3 * (x + 1) ** (2/3))
    
    # Вычисляем производную в полученном корне
    deriv_at_root = phi_prime(root)
    print(f"φ'({root:.6f}) = {deriv_at_root:.6f}")
    print(f"|φ'({root:.6f})| = {abs(deriv_at_root):.6f} < 1? {abs(deriv_at_root) < 1}")
    
    if abs(deriv_at_root) < 1:
        print("✓ Условие сходимости выполняется!")
    else:
        print("✗ Условие сходимости не выполняется!")


if __name__ == "__main__":
    main()