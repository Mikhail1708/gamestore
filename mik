import math

def simple_iteration(phi, x0, eps=1e-6, max_iter=1000):
    """
    Метод простой итерации для решения уравнения x = phi(x)

    Параметры:
    phi - итерационная функция
    x0 - начальное приближение
    eps - требуемая точность
    max_iter - максимальное число итераций

    Возвращает:
    корень, число итераций, историю приближений
    """
    x_prev = x0
    history = [x0]

    for i in range(max_iter):
        x_next = phi(x_prev)
        history.append(x_next)

        # Критерий остановки: |x_{n+1} - x_n| < eps
        if abs(x_next - x_prev) < eps:
            return x_next, i + 1, history

        x_prev = x_next

    print(f"Достигнуто максимальное число итераций ({max_iter})")
    return x_prev, max_iter, history


def check_convergence(phi_prime, x_range, n_points=1000):
    """
    Проверка условия сходимости |phi'(x)| < 1 на заданном интервале
    """
    x_min, x_max = x_range
    step = (x_max - x_min) / (n_points - 1)
    
    max_derivative = 0
    for i in range(n_points):
        x = x_min + i * step
        try:
            deriv = abs(phi_prime(x))
            if deriv > max_derivative:
                max_derivative = deriv
        except:
            continue
    
    return max_derivative < 1, max_derivative


def example1():
    """Пример 1: x³ - x - 1 = 0"""
    print("=" * 50)
    print("Пример 1: Решение уравнения x³ - x - 1 = 0")
    print("Преобразование: x = ∛(x + 1)")
    
    # Итерационная функция
    phi = lambda x: (x + 1) ** (1/3)
    
    # Проверка сходимости
    phi_prime = lambda x: (1/3) * (x + 1) ** (-2/3)
    conv, max_deriv = check_convergence(phi_prime, (1.0, 1.5))
    print(f"Условие сходимости: {conv} (max|φ'(x)| = {max_deriv:.4f})")
    
    # Решение
    x0 = 1.0
    eps = 0.001
    root, iterations, history = simple_iteration(phi, x0, eps)
    
    print(f"\nНачальное приближение: x0 = {x0}")
    print(f"Требуемая точность: ε = {eps}")
    print(f"\nРезультаты:")
    print(f"Корень: x ≈ {root:.6f}")
    print(f"Число итераций: {iterations}")
    print(f"f({root:.6f}) = {root**3 - root - 1:.6f}")
    
    # Вывод истории итераций
    print(f"\nИстория итераций:")
    for i, x in enumerate(history[:min(6, len(history))]):
        if i < len(history) - 1:
            diff = abs(history[i+1] - x)
            print(f"Итерация {i}: x_{i} = {x:.6f}, x_{i+1} = {history[i+1]:.6f}, |Δ| = {diff:.6f}")
    
    return root, iterations


def example2():
    """Пример 2: cos(x) - x = 0"""
    print("\n" + "=" * 50)
    print("Пример 2: Решение уравнения cos(x) - x = 0")
    print("Преобразование: x = cos(x)")
    
    # Итерационная функция
    phi = lambda x: math.cos(x)
    
    # Проверка сходимости
    phi_prime = lambda x: -math.sin(x)
    conv, max_deriv = check_convergence(phi_prime, (0.5, 1.0))
    print(f"Условие сходимости: {conv} (max|φ'(x)| = {max_deriv:.4f})")
    
    # Решение
    x0 = 0.5
    eps = 0.0001
    root, iterations, history = simple_iteration(phi, x0, eps, max_iter=50)
    
    print(f"\nНачальное приближение: x0 = {x0}")
    print(f"Требуемая точность: ε = {eps}")
    print(f"\nРезультаты:")
    print(f"Корень: x ≈ {root:.6f}")
    print(f"Число итераций: {iterations}")
    print(f"f({root:.6f}) = {math.cos(root) - root:.6f}")
    
    # Вывод первых и последних итераций
    print(f"\nИстория итераций (первые 5 и последние 5):")
    for i, x in enumerate(history[:5]):
        if i < len(history) - 1:
            diff = abs(history[i+1] - x)
            print(f"Итерация {i}: x_{i} = {x:.6f}, x_{i+1} = {history[i+1]:.6f}, |Δ| = {diff:.6f}")
    
    if len(history) > 10:
        print("...")
        for i in range(max(5, len(history)-5), len(history)-1):
            diff = abs(history[i+1] - history[i])
            print(f"Итерация {i}: x_{i} = {history[i]:.6f}, x_{i+1} = {history[i+1]:.6f}, |Δ| = {diff:.6f}")
    
    return root, iterations


def example3():
    """Пример 3: x² - 2 = 0 (нахождение √2)"""
    print("\n" + "=" * 50)
    print("Пример 3: Решение уравнения x² - 2 = 0 (нахождение √2)")
    print("Преобразование: x = (x + 2/x)/2 (метод Ньютона)")
    
    # Итерационная функция
    phi = lambda x: (x + 2/x) / 2
    
    # Проверка сходимости
    phi_prime = lambda x: 0.5 * (1 - 2/(x**2))
    conv, max_deriv = check_convergence(phi_prime, (1.0, 2.0))
    print(f"Условие сходимости: {conv} (max|φ'(x)| = {max_deriv:.4f})")
    
    # Решение
    x0 = 1.0
    eps = 0.00001
    root, iterations, history = simple_iteration(phi, x0, eps)
    
    print(f"\nНачальное приближение: x0 = {x0}")
    print(f"Требуемая точность: ε = {eps}")
    print(f"\nРезультаты:")
    print(f"Корень: x ≈ {root:.8f}")
    print(f"√2 (точное значение): {math.sqrt(2):.8f}")
    print(f"Число итераций: {iterations}")
    print(f"f({root:.8f}) = {root**2 - 2:.8f}")
    
    # Вывод истории итераций
    print(f"\nИстория итераций:")
    for i, x in enumerate(history):
        if i < len(history) - 1:
            diff = abs(history[i+1] - x)
            print(f"Итерация {i}: x_{i} = {x:.8f}, x_{i+1} = {history[i+1]:.8f}, |Δ| = {diff:.8f}")
    
    return root, iterations


def solve_equation_interactive():
    """Интерактивное решение уравнения методом простой итерации"""
    print("\n" + "=" * 50)
    print("ИНТЕРАКТИВНОЕ РЕШЕНИЕ УРАВНЕНИЙ")
    print("=" * 50)
    
    print("Доступные варианты уравнений:")
    print("1. x³ - x - 1 = 0")
    print("2. cos(x) - x = 0")
    print("3. x² - 2 = 0")
    print("4. Ввести свое уравнение")
    
    choice = input("\nВыберите вариант (1-4): ")
    
    if choice == '1':
        example1()
    elif choice == '2':
        example2()
    elif choice == '3':
        example3()
    elif choice == '4':
        custom_equation()
    else:
        print("Неверный выбор")


def custom_equation():
    """Решение пользовательского уравнения"""
    print("\nВведите уравнение в виде f(x) = 0")
    print("Примеры: x**3 - 2*x - 5, math.exp(x) - 3*x, math.sin(x) - x/2")
    
    # Получаем функцию от пользователя
    func_str = input("Введите f(x) (используйте math. для функций): ")
    
    # Создаем функцию из строки
    try:
        f = lambda x: eval(func_str, {"math": math, "x": x})
    except:
        print("Ошибка в определении функции")
        return
    
    # Получаем итерационную функцию
    print("\nВведите итерационную функцию φ(x) (должна быть в виде x = φ(x))")
    print("Примеры: (x + 5/x)/2, math.cos(x), (x**3 + 1)**(1/3)")
    phi_str = input("Введите φ(x): ")
    
    try:
        phi = lambda x: eval(phi_str, {"math": math, "x": x})
    except:
        print("Ошибка в определении итерационной функции")
        return
    
    # Получаем параметры
    try:
        x0 = float(input("Введите начальное приближение x0: "))
        eps = float(input("Введите точность ε: "))
        max_iter = int(input("Введите максимальное число итераций: "))
    except:
        print("Ошибка ввода числовых параметров")
        return
    
    # Решаем
    root, iterations, history = simple_iteration(phi, x0, eps, max_iter)
    
    print(f"\nРезультаты:")
    print(f"Корень: x ≈ {root:.8f}")
    print(f"Число итераций: {iterations}")
    print(f"f({root:.8f}) = {f(root):.8f}")
    
    if iterations < 10:
        print(f"\nИстория итераций:")
        for i, x in enumerate(history):
            if i < len(history) - 1:
                diff = abs(history[i+1] - x)
                print(f"Итерация {i}: x_{i} = {x:.8f}, x_{i+1} = {history[i+1]:.8f}, |Δ| = {diff:.8f}")


def main():
    """Основная функция"""
    print("МЕТОД ПРОСТОЙ ИТЕРАЦИИ ДЛЯ РЕШЕНИЯ НЕЛИНЕЙНЫХ УРАВНЕНИЙ")
    print("=" * 60)
    
    # Запуск всех примеров
    results = []
    
    results.append(example1())
    results.append(example2())
    results.append(example3())
    
    print("\n" + "=" * 50)
    print("СВОДКА РЕЗУЛЬТАТОВ:")
    print("=" * 50)
    print(f"{'Уравнение':<30} {'Корень':<15} {'Итераций':<10}")
    print("-" * 50)
    equations = ["x³ - x - 1 = 0", "cos(x) - x = 0", "x² - 2 = 0"]
    for i, (root, iters) in enumerate(results):
        print(f"{equations[i]:<30} {root:<15.6f} {iters:<10}")
    
    # Интерактивный режим
    while True:
        response = input("\nЗапустить интерактивный режим? (y/n): ")
        if response.lower() == 'y':
            solve_equation_interactive()
        else:
            break
    
    print("\nПрограмма завершена.")


if __name__ == "__main__":
    main()