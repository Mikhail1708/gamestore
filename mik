
def check_palindrome(text: str) -> str:
    cleaned = ''.join(char.lower() for char in text if char.isalnum())
    
    if cleaned == cleaned[::-1] and cleaned:
        return f"✓ '{text}' — это палиндром!"
    return f"✗ '{text}' — это НЕ палиндром"

# Интерактивный режим
print("=== ПРОВЕРКА ПАЛИНДРОМОВ ===")
print("(Для выхода введите 'exit')\n")

while True:
    user_input = input("Введите строку для проверки: ").strip()
    
    if user_input.lower() == 'exit':
        print("Программа завершена.")
        break
    
    if not user_input:
        print("⚠ Вы ввели пустую строку!\n")
        continue
    
    result = check_palindrome(user_input)
    print(result + "\n")


def is_palindrome(s: str) -> bool:
    s = ''.join(c.lower() for c in s if c.isalnum())
    for i in range(len(s) // 2):
        if s[i] != s[-(i + 1)]:
            return False
    return True


import math

def simple_iteration(phi, x0, eps=0.001, max_iter=100):
    """
    Решение уравнения x = phi(x) методом простой итерации
    """
    x_prev = x0
    print(f"Начальное приближение: x₀ = {x0}")
    print(f"Требуемая точность: ε = {eps}")
    print("-" * 60)
    print(f"{'Итерация':<10} {'xₙ':<15} {'xₙ₊₁ = φ(xₙ)':<20} {'|xₙ₊₁ - xₙ|':<15}")
    print("-" * 60)
    
    for i in range(max_iter):
        x_next = phi(x_prev)
        diff = abs(x_next - x_prev)
        
        print(f"{i:<10} {x_prev:<15.6f} {x_next:<20.6f} {diff:<15.6f}")
        
        # Проверка условия остановки
        if diff < eps:
            print("-" * 60)
            print(f"\nУсловие |xₙ₊₁ - xₙ| < ε достигнуто на итерации {i+1}")
            return x_next, i + 1
        
        x_prev = x_next
    
    print("-" * 60)
    print(f"\nДостигнуто максимальное число итераций ({max_iter})")
    return x_prev, max_iter


def main():
    print("МЕТОД ПРОСТОЙ ИТЕРАЦИИ")
    print("=" * 60)
    print("Решение уравнения: x³ - x - 1 = 0")
    print("Преобразование: x = ∛(x + 1)")
    print("=" * 60)
    
    # Итерационная функция: φ(x) = ∛(x + 1)
    phi = lambda x: (x + 1) ** (1/3)
    
    # Параметры метода
    x0 = 1.0          # Начальное приближение
    eps = 0.001       # Точность
    
    # Решение уравнения
    root, iterations = simple_iteration(phi, x0, eps)
    
    # Вывод результатов
    print(f"\nРЕЗУЛЬТАТЫ:")
    print(f"Приближенный корень: x ≈ {root:.6f}")
    print(f"Количество итераций: {iterations}")
    
    # Проверка решения
    f_root = root**3 - root - 1
    print(f"Проверка: f({root:.6f}) = {root:.6f}³ - {root:.6f} - 1 = {f_root:.6f}")
    
    # Точное значение для сравнения
    print(f"\nТочное значение корня: ≈ 1.324717957")
    print(f"Погрешность: {abs(root - 1.324717957):.10f}")
    
    # Проверка условия сходимости
    print("\n" + "=" * 60)
    print("ПРОВЕРКА УСЛОВИЯ СХОДИМОСТИ:")
    print("Метод сходится, если |φ'(x)| < 1 в окрестности корня")
    
    # Производная φ(x) = ∛(x + 1)
    # φ'(x) = 1/(3*(x+1)^(2/3))
    phi_prime = lambda x: 1 / (3 * (x + 1) ** (2/3))
    
    # Вычисляем производную в полученном корне
    deriv_at_root = phi_prime(root)
    print(f"φ'({root:.6f}) = {deriv_at_root:.6f}")
    print(f"|φ'({root:.6f})| = {abs(deriv_at_root):.6f} < 1? {abs(deriv_at_root) < 1}")
    
    if abs(deriv_at_root) < 1:
        print("✓ Условие сходимости выполняется!")
    else:
        print("✗ Условие сходимости не выполняется!")


if __name__ == "__main__":
    main()